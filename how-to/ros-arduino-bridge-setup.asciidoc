= ros_arduino_bridge Setup

`ros_arduino_bridge` is a set of ROS packages designed to make integrating an Arduino-compatible MCU into ROS
easier. It consists of these packages:

* `ros_arduino_bridge` -- The main package, empty.
* `ros_arduino_msgs` -- Definitions of ROS messages used by `ros_arduino_bridge`.
* `ros_arduino_python` -- Python modules and a ROS node that handles the communication.
* `ros_arduino_firmware` -- An Arduino sketch and libraries for the Arduino side.

== Summary of Integration

Here's a summary of what you have to do to use `ros_arduino_bridge` for your PRSG2-style robot:

. Get the code.
. Choose your communication style and wire the UART, if necessary.
. Choose pins and wire the sensors and encoders.
. Edit the Arduino sketch to use your choices and upload to the A-Star.
. Create a launch file incorporating your sensor definitions.
. Launch ROS and test the setup.

Each step is detailed in sections below.

== Getting the Code

Marco has forked
link:https://github.com/hbrobotics/ros_arduino_bridge[the original project] and modified it to add I2C communication.
Mark R. has added some fixes and enhancements which Marco has incorporated. Right now it is best to get the latest from
Marco's `indigo-devel` branch (the default):

link:https://github.com/mw46d/ros_arduino_bridge[Marco's `ros_arduino_bridge` repository]

Clone the repository into your Catkin workspace in the `catkin_ws/src` directory. (Note: If you are not running
the Arduino IDE on your robot, then clone the code again onto the computer where you use the Arduino IDE.)

== Communication Styles

`ros_arduino_bridge` can communication between ROS and the Arduino over three different communication paths:

* I2C -- Allows higher data rates. Marco has also added checksums for messages on this path. The Pi seems to have problems with higher rates, I currently limit it to 30000 baud or something like that.
* USB serial -- Does not require any direct wiring, just a USB cable between the Raspberry Pi and Arduino.
* UART serial -- Uses the A-Star UART on pins 0 and 1 to communicate with the Raspberry Pi UART. Requires one level converter be soldered in on the A-Star, for the Arduino-to-RPi direction, since the RPi UART uses 3V levels.

Either the I2C or UART serial methods allow the A-Star USB to be used for debug communication, making them slightly preferable. Using I2C gives higher transmission rates but uses the A-Star I2C pins. If you want to talk to I2C devices from the A-Star, you may want to keep these pins free. All three methods work fine -- the choice is really a personal preference.

=== Wiring for the UART

If you use USB serial or I2C there is no additional wiring required. The I2C pins are already tied together between the RPi and the A-Star through level shifters.

If you want to use the UART, you need to solder in headers for one of the A-Star level shifters, and wire things this way:

* RPi GPIO 14 (Tx) -> A-Star pin 0 (Rx)
* RPi GPIO 15 (Rx) -> Level shifter low-side
* Level shifter high-side -> A-Star pin 1 (Tx)


== IR and Encoder Pins

Marco and Mark have made different choices of pin assignments on their robots. You can choose one of these, or
decide to come up with your own.

.A-Star Pin Assignments
[options="header"]
|=====
| Pin | Marco's robot | Mark's robot | Other A-Star use
| A0 | IR sensor 1 o'clk | IR sensor (L) |
| A1 | IR sensor 2 o'clk (no jumper) | A-Star battery voltage | Analog input tied to battery voltage if jumper in place
| A2 | IR sensor 10 o'clk | IR sensor (LF) |
| A3 | IR sensor 11 o'clk | IR sensor (F) |
| A4 | IR sensor 4 o'clk | IR sensor (RF) |
| A5 | IR sensor 7 o'clk | IR sensor (R ) |
| 4/A6 | IR sensor 5 o'clk | unused |
| 5 | Right encoder B | unused |
| 6/A7 | IR sensor 8 o'clk | unused |
| 7 | Right encoder XOR | Left encoder A | Hardware interrupt
| 8/A8 | Left encoder XOR | unused | Pin-change interrupt
| 11 | Left encoder B | Left encoder B | Pin-change interrupt
| 15 | unused | Right encoder A | Pin-change interrupt, SPI SCK
| 16 | unused | Right encoder B | Pin-change interrupt, SPI MOSI
|=====

Marco feeds both encoder inputs (A and B) through an XOR gate, as well as reading B separately. This only requires one
pin to have an interrupt. He has used 5, 7, 8, and 11 to keep the encoder inputs nearby on the same rail. However, pin
8 is also tied to analog A8, so one analog pin is used. Pin 7 supports hardware interrupts, while pin 8 supports pin-change
interrupts.

Mark wanted to keep all analog inputs free, in case more analog sensors were added, so he moved the right encoder inputs
to the SPI pins. This means that you can't use SPI if you use his arrangement, but analog A8 is still available. Again,
pin 7 is a hardware interrupt, while 11, 15, and 16 support pin-change interrupts. To reduce the frequency of interrupt
processing, if you use Mark's arrangement only the A encoder inputs are tied to interrupts, and the tick counter is
incremented or decremented by 2 at each interrupt.

== Customizing the Arduino Sketch

There are different customizations needed depending on whether you Marco's pin assignments and I2C or Mark's pin assignments and UART serial.

=== Marco's Approach

If you are using I2C communication and Marco's pin assignments, find the line that reads `#define SERIAL_STREAM Serial` and insert a new line above it that says `#define USE_I2C`. The result should look like this:

   #define USE_I2C
   #define SERIAL_STREAM Serial1
   #define DEBUG_SERIAL_STREAM Serial

=== Mark's Approach

If you are using the UART for serial communication and Mark's pin assignments, you must edit two lines:

. Change the line that reads `#define SERIAL_STREAM Serial` to read `#define SERIAL_STREAM Serial1` (the Arduino UART object).
. Uncomment the line that reads `//#define USE_ENABLE_INTERRUPT` to that it says `#define USE_ENABLE_INTERRUPT`.

=== A Custom Approach

The pins used by the encoders are defined in the file `diff_controller.h`. Modify the pin assignments to fit your robot.

If you are using I2C, add a line `#define USE_I2C` just before the line that says `#define SERIAL_STREAM Serial`.

If you are using the UART for serial communication, change the line that reads `#define SERIAL_STREAM Serial` to read `#define SERIAL_STREAM Serial1` (the Arduino UART object).

=== Uploading the Sketch and Testing

. Power up your robot so that the Raspberry Pi gets sufficient power to boot Linux. (I don't believe it's good to
run the Raspberry Pi entirely on USB power from the host computer, since the power output is probably limited to 1A.)
. Connect your robot to the computer running the Arduino IDE through a USB cable.
. In the Arduino IDE, choose a _Leonardo_ board under Tools > Board, and select the proper port under Tools > Port.
. If you are using the UART, temporarily change the `SERIAL_STREAM` definition to `Serial` (the USB serial port).
. Upload the sketch to the A-Star.

You can test the sketch as follows:

. Open a serial monitor using Tools > Serial Monitor.
. Set the baud rate to 115200, and set the line ending to _Carriage return_.
. In the text box at the top, type `a 0` (with a space between) and press _Send_. The value of the analog pin A0 will be displayed. If you have an IR sensor connected, you should be able to move your hand closer or farther away and see the difference in analog value by using the `a 0` command repeatedly.

Other things you can test:

`a 106` -- A fake analog pin number designating the battery voltage, in millivolts. (This will be the VIN voltage if
you are plugged into a power supply rather than the battery.)

`d 100` -- A digital value of 0 or 1 depending on whether the A-Star button A is pressed. (`d 101` gives button B. Unfortunately, reading button C interferes with PWM on motor 1 -- not sure why.)

`u 100:0:0:100` -- Sets the PID parameters Kp, Ki, Kd, and Ko. (The first three are divided by Ko, in this PID setup.) These values work well.

`m 50 50` -- Sets the motor speeds to 50 ticks per PID cycle. (Default cycle is 30Hz.) Max motor speed is about 120 counts per cycle, I think. (Once you set things up on ROS, we'll deal with meters per second instead of counts.)

If you are using the UART for serial communication, change the line back to `#define SERIAL_STREAM Serial1` and upload the sketch again.
